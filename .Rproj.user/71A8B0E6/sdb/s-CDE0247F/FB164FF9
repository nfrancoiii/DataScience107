{
    "contents" : "---\ntitle: Data Wrangling with `dplyr` \nauthor: Stephanie Hicks, Rafael Irizarry\n---\n\nOnce data has been transformed into a **tidy** tabular format, an \nimportant part of \"data wrangling\" or \"data munging\" is data transformation. \n\n![Bottlenecks in data analysis](http://r4ds.had.co.nz/diagrams/data-science.png)\n\nWe have learned about some functions in the R package `dplyr` that can \ntransform and summarize tabular data with rows and columns. \nFor example, when data is a tabular format, you have seen how we \ncan use `dplyr` to `filter()` rows, `select()` columns and add \nnew columns using `mutate()`. Now we will \nexplore some more advanced `dplyr` functionality.  \n\n### Brief recap of dplyr\n\n[`dplyr`](http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html) \nis a powerful R-package to transform and summarize tabular data with rows \nand columns. \n\nThe package contains a set of functions (or \"verbs\") to perform common data \nmanipulation operations such as filtering for rows, selecting specific \ncolumns, re-ordering rows, adding new columns and summarizing data. \nIn addition, `dplyr` contains a useful function to perform another common task \nwhich is the is the \"split-apply-combine\" concept.  We will discuss that in a\nlittle bit. \n\n# Data\n\n## mammals sleep\n\nThe `msleep` (mammals sleep) data set contains the sleeptimes and weights for \na set of mammals and is available in the [`data` repository on GitHub](https://raw.githubusercontent.com/datasciencelabs/data/master/msleep_ggplot2.csv). \nThis data set contains 83 rows and 11 variables.  \n\nTo load the `msleep` data set\n\n```{r, message=FALSE, warning=FALSE}\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nmsleep <- read_csv(\"https://raw.githubusercontent.com/datasciencelabs/data/master/msleep_ggplot2.csv\")\nmsleep\n```\n\nThe columns (in order) correspond to the following: \n\ncolumn name | Description\n--- | ---\n`name` | common name\n`genus` | taxonomic rank\n`vore` | carnivore, omnivore or herbivore?\n`order` | taxonomic rank\n`conservation` | the conservation status of the mammal\n`sleep_total` | total amount of sleep, in hours\n`sleep_rem` | rem sleep, in hours\n`sleep_cycle` | length of sleep cycle, in hours\n`awake` | amount of time spent awake, in hours\n`brainwt` | brain weight in kilograms\n`bodywt` | body weight in kilograms\n\n\n# Important `dplyr` verbs to remember\n\n`dplyr` verbs | Description\n--- | ---\n`select()` | select columns \n`mutate()` | create new columns\n`filter()` | filter rows\n`arrange()` | re-order or arrange rows\n`summarise()` | summarise values\n`group_by()` | allows for group operations in the \"split-apply-combine\" concept\n\n\n\n# `dplyr` verbs in action\n\n### `select()` and `mutate`() columns; `filter()` rows\n\nThe two most basic functions are `select()` and `filter()` which selects \ncolumns and filters rows, respectively. The function `mutate()` can be used \nto create new columns. We have already seen examples of all of these\nin class. \n\nFor example, to select a range of columns by name, use the \":\" (colon) operator\n\n```{r}\nmsleep %>% select(name:order)\n```\n\nTo select all columns that start with the character string \"sl\", use the \nfunction `starts_with()`\n\n```{r}\nmsleep %>% select(starts_with(\"sl\"))\n```\n\nSome additional options to select columns based on a specific criteria include\n\n1. `ends_with()` = Select columns that end with a character string\n2. `contains()` = Select columns that contain a character string\n3. `matches()` = Select columns that match a regular expression\n4. `one_of()` = Select columns names that are from a group of names\n\n\n#### Assessment\n\nSelect all columns except those from `genus` to `conservation` and \nfilter the rows for mammals that sleep a total of more than 16 hours\nand have a body weight of greater than 1 kilogram\n\n```{r}\n## Provide your code here\nmsleep %>% \n  select(-c(genus:conservation)) %>%\n  filter(sleep_total >= 16 & bodywt >= 1)\n\n```\n\n#### Assessment\n\nCreate a new column called `rem_proportion` which is the ratio of \nrem sleep to total amount of sleep and create boxplots of the \n`rem_proportion` column split and colored by the `vore` column. \nCreate labels for the `x` and `y` axis.  \n```{r}\n## Provide your code here\nmsleep %>%\n  mutate(rem_proportion = sleep_rem / sleep_total) %>%\n  ggplot(aes(x = vore, y = rem_proportion, fill = vore)) +\n    geom_boxplot() + xlab(\"Type of Diet\") +\n    ylab(\"Proportion\") + labs(title = \"proportion of rem sleep\")\n```\n\n\n#### Assessment (optional)\n\nSelect all columns that start with the character string \"sl\" or ends\nwith the character string \"wt\", create a new\ncolumn called `rem_proportion` which is the ratio of rem sleep \nto total amount of sleep, create a second column `bodywt_grams` which\nis the bodywt column in grams and filter for the rows 20 to 30 in \nthe msleep data set by numerical position. \n\nHint: Look at the `slice()` help file to filter for rows by numerical \nposition. \n\n```{r}\n## Provide your code here\n\nmsleep %>% \n  select(starts_with(\"sl\"), ends_with(\"wt\")) %>%\n  mutate(rem_proportion = sleep_rem / sleep_total,\n         bodywt_grams = bodywt * 1000) %>% \n  slice(20:30)\n\n```\n\n\n### Arrange or re-order rows using `arrange()`\n\nTo arrange (or re-order) rows by a particular column such as the taxonomic\norder, list the name of the column you want to arrange the rows by\n\n```{r}\nmsleep %>% \n    arrange(order)\n```\n\n\n#### Assessment\n\nSelect all columns names with the characters \"sleep\" and arrange the rows \nfor the `sleep_rem` in a decreasing order.\n\nHint: look at the `?arrange` help file for the `desc()` option.\n\n```{r}\n## Provide your code here\nmsleep %>%\n    select(matches(\"sleep\")) %>%\n  arrange(desc(sleep_rem))\n```\n\n#### Assessment\n\nSelect three columns from `msleep` (`name`, `order`, `sleep_total`), \narrange the rows in the `sleep_total` column in a descending order, and \nfilter the rows for mammals that sleep for a total of 16 or more hours. \n\n```{r}\n## Provide your code here\nmsleep %>%\n  select()\n```\n\n\n\n### Create summaries of the data frame using `summarise()`\n\nThe `summarise()` function will create summary statistics for a given column \nin the data frame such as finding the mean. For example, to compute the \naverage number of hours of sleep, apply the `mean()` function to the \ncolumn `sleep_total` and call the summary value `avg_sleep`. \n\n```{r}\nmsleep %>% \n    summarise(avg_sleep = mean(sleep_total))\n```\n\nThere are many other summary statistics you could consider such `sd()`, \n`min()`, `max()`, `median()`, `sum()`, `n()` (returns the length of vector), \n`first()` (returns first value in vector), `last()` (returns last value in \nvector) and `n_distinct()` (number of distinct values in vector). \n\n\n#### Assessment\n\nSummarize `sleep_total` column in the `msleep` data set with the \naverage sleep, the minimum and maximum amount of sleep, and the \ntotal number of mammals. \n\n```{r}\n## Provide your code here\n\n```\n\n    \n### Group operations using `group_by()`\n\nThe `group_by()` verb is an important function in `dplyr`. As we mentioned \nbefore it's related to concept of \"split-apply-combine\". We literally want to \nsplit the data frame by some variable (e.g. `vore`), apply a \nfunction to the individual data frames and then combine the output. \n\nSay we wanted to calculate the standard deviation of the body \nand brain weights for each of factor in the `vore` column.  First, we can \nlook at the types of factors in the `vore` column\n```{r}\ntable(msleep$vore)\n```\n\nThen, we could use `filter()` to filter for rows that contain \"carni\" in the \n`vore` column and summarize with the mean of the brain and body\nweights. \n```{r}\nmsleep %>% \n    filter(vore == \"carni\") %>% \n    summarize(\"bodywt_sd\" = mean(bodywt), \n              \"brainwt_sd\" = mean(brainwt, na.rm = TRUE))\n```\n\nWe could repeat this for each factor in `vore`, which is a bit teadious.\nInstead, we could use this using the `group_by()` function. \n\nLet's do that: split the `msleep` data frame by the `vore` column, \nthen calculate the mean of body weight and brain weight \nfor each invididual data frame. (hint: We expect a set of summary \nstatistics for each level in `vore`.)\n\n```{r}\nmsleep %>% \n    group_by(vore) %>%\n    summarize(\"bodywt_sd\" = mean(bodywt), \n              \"brainwt_sd\" = mean(brainwt, na.rm = TRUE))\n```\n\n\n#### Assessment\n\nSplit the `msleep` data frame by the taxonomic order, then for each \ntaxonomic order summarize the `sleep_total` with the average sleep, \nthe minimum and maximum amount of sleep, and the total number of mammals\nin each order. \n\n```{r}\n## Provide your code here\n\n```\n\n\n\n# joining two data frames in `dplyr`\n\nThe last part of `dplyr` that we will discuss are a set of `dplyr` \nverbs that allow you to join two data sets.\n\n`dplyr` verbs to join two tables (`x`, `y`) | Description\n--- | ---\n`inner_join(x, y)` | join data (retain only rows in both sets)\n`left_join(x, y)` | join matching rows from `y` to `x`\n`right_join(x, y)` | join matching rows from `x` to `y`\n`full_join(x, y)` | join data (retain all values, all rows)\n`semi_join(x, y)` | all rows in `x` that match in `y`\n`anti_join(x, y)` | all rows in `x` that do have a match in `y`\n\n\n## Data\n\nFor this section, we will work with two small data sets related to the \n2016 Oscars Nominations. The two data sets are `oscars` and `movies`.  The \nfirst data set contains information about the the name of the actor/actress,\nthe name of the movie and the category for nomination.  The second \ndata set contains a list of movies and the length of the movie in minutes. \n\nWe will explore the `dplyr` verbs to join the two tables.  First let's load\nthe data. \n\n```{r}\nlibrary(readr)\n\noscars <-\"\nname,movie,category\nAdam McKay,The Big Short,Best Director\nAlejandro González Iñárritu,The Revenant,Best Director\nLenny Abrahamson,Room,Best Director\nTom McCarthy,Spotlight,Best Director\nGeorge Miller,Mad Max: Fury Road,Best Director\nBryan Cranston,Trumbo,Best Actor\nMatt Damon,The Martian,Best Actor\nMichael Fassbender,Steve Jobs,Best Actor\nLeonardo DiCaprio,The Revenant,Best Actor\nEddie Redmayne,The Danish Girl,Best Actor\nCate Blanchett,Carol,Best Actress\nBrie Larson,Room,Best Actress\nJennifer Lawrence,Joy,Best Actress\nCharlotte Rampling,45 Years,Best Actress\nSaoirse Ronan,Brooklyn,Best Actress\n\"\noscars <- read_csv(oscars, trim_ws = TRUE, skip = 1)\noscars \n\nmovies <-\"\nmovie,length_mins\nThe Big Short,130\nStar Wars: The Force Awakens,135\nBrooklyn,111\nMad Max: Fury Road,120\nRoom,118\nThe Martian,144\nThe Revenant,156\nSpotlight,128\n\"\nmovies <- read_csv(movies, trim_ws = TRUE, skip = 1)\nmovies \n```\n\n### inner_join(x,y)\n\nThis function joins all rows from x where there are matching \nvalues in y, and all columns from x and y. If there are multiple matches\nbetween x and y, all combination of the matches are returned.\n\n```{r}\ninner_join(oscars, movies, by = \"movie\")\n```\n\n\n### semi_join(x,y)\n\nThis function returns all rows from x where there are matching values \nin y, keeping just columns from x. A semi join differs from an \ninner join because an inner join will return one row of x for \neach matching row of y, where a semi join will never duplicate \nrows of x.\n\n```{r}\nsemi_join(oscars, movies, by = \"movie\")\n```\n\n#### Assessment \n\nTry applying the `semi_join()` function with `x=movies` and `y=oscars`. \nWhat is the difference? \n\n```{r}\n## Provide your code here \n\n```\n\n\n### Assessment \n\nUsing the `dplyr` join functions, combine the columns from the \n`oscars` and `movies` data sets and return all rows from the `oscars` data \nset and all columns in both the `oscars` and `movies` columns. \n\nHint: read the help file for `left_join()` or `right_join()`. \n\n```{r}\n## Provide your code here\n\n```\n\nWhy are there NAs? \n\n\n### Assessment\n\nUsing the `dplyr` join functions, combine the columns from the \n`oscars` and `movies` data sets and return all rows from the `movies` data \nset and all columns in both the `oscars` and `movies` columns. \n\n```{r}\n## Provide your code here\n\n```\n\n\n### full_join(x,y)\n\nThis function returns all rows and all columns from both x and y. \nWhen there are not matching values, it will return NA for the one missing. \n\n```{r}\nfull_join(oscars, movies, by = \"movie\")\nfull_join(movies, oscars, by = \"movie\")\n```\n\n### Assessment\n\nUsing the `dplyr` join functions, return all rows from `oscars` data set \nwhere there are not matching values in `movies`, only keeping the \ncolumns from the `oscars` data set.\n\nHint: Read the help file for `anti_join()`. \n\n```{r}\n## Provide your code here\n\n```\n\n\n\n\n\n# Cheatsheets\n\n* [Data Wrangling with dplyr and tidyr from RStudio](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)\n\n\n\n",
    "created" : 1454987105039.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2320612850",
    "id" : "FB164FF9",
    "lastKnownWriteTime" : 1454993743,
    "path" : "~/Google Drive/COLLEGE WORK/Harvard Extension School/DataScience107/data_wrangling_with_dplyr.Rmd",
    "project_path" : "data_wrangling_with_dplyr.Rmd",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_markdown"
}